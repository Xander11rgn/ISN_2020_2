# Отчет по лабораторной работе №4
## по дисциплине Инфокоммуникационные системы и сети  

### _Цели и задачи практического задания:_ изучение методов работы компонентов PWA приложений

### 1. _Service Worker_  
В рамках задания была изучена предложенная документация по компоненту Service Worker.  
Ответы на вопроосы:  

_1.1 Какие технологии лежат в основе Service Worker?_  
- JavaScript;
- архитектура на промисах (Promise);
- обязательность HTTPS.  
  
_1.2 Как работает Service Worker?_  
Сперва веб-страница регистрирует service worker, используя .js-файл, содержащий код сервис-воркера. Service worker устанавливается, активируется и начинает в фоновом режиме прослушивать события "fetch" и "message" и при необходимости их изменять или отменять совсем. Также, при обработке события install в коде сервис-воркера происходит открытие кэша и кэширование необходимых материалов. Этот функционал в дальнейшем позволит веб-приложению работать оффлайн.  

_1.3 Возможно ли проксирование запросов с разных удаленных серверов с разными IP адресами? Почему и как можно реализовать?_  
Нет, Service Worker работает только с тем адресом, с которого загружен его код. То есть можно перехватывать только запросы к своему домену. Притом, данная функция доступна только для не кросдоменных запросов (CORS). Для проксирования запросов с чужих серверов в 2016 году Google предлагал введение события "foreignfetch", но на данный момент эту идею полностью закрыли. Возможно, реализовать такое можно, используя Cross-Origin worker'a.  

_1.4 Сохраняется ли проксированный контент? Как настроить сохранение запросов в ServiceWoker?_  
Данные в кеше сохраняются до тех пор, пока разработчик сам не решит их удалить. Для кэширования следует использовать встроенный API хранилища Service Worker — cache — глобальный для всех сервис-воркеров, который позволяет нам хранить результаты запросов.  

_1.5 Какие есть ограничения в работе Service Woker?_  
- работа только на localhost либо по протоколу HTTPS;
- поддерживаемость далеко не всеми браузерами;
- невозможность проксировать CORS-запросы.  

### 2. _IndexedDB_  
В рамках данного задания была изучена предложенная документация по IndexedDB.  
Ответы на вопроосы:  

_2.1 Каким типом хранилища является IndexedDB?_  
Это хранилище ключей/значений (база данных noSQL).  
  
_2.2 Какая последовательность работы с хранилищем?_  
Работа с базой данных начинается с запроса на открытие. Затем необходимо создать хранилище объектов в базе данных, над которой будут выполняться операции. Далее запустить транзакцию и задать некоторый запрос, например, добавление или извлечение данных. Дождаться завершения операции, "слушая" событие DOM, на которое должен быть установлен обработчик, и сделать что-то с результатами.  

_2.3 Какой жизненный цикл хранилища?_  
Открытие БД -> Создание хранилища -> Некоторая работа -> Удаление хранилища -> Удаление БД   

_2.4 Будет ли доступна информация из хранилища при закрытии веб-приложения? Если нет – какой тип хранилища надо использовать?_  
Да, IndexedDB предоставляет возможность постоянно хранить данные внутри пользовательского браузера. Это позволяет создавать web-приложения с богатыми возможностями в независимости от доступа к сети. Такие приложения могут работать как online, так и offline.  

_2.5 Будет ли доступно хранилище двум одновременно открытым экземплярам веб-приложения? Почему?_  
IndexedDB - транзакционная БД. Все, что происходит внутри - происходит в контексте транзакции. Кроме того, концепция IndexedDB гарантирует атомарность транзакций. К тому же данное хранилище - асинхронное. Всё это позволяет поддерживать доступность хранилища двум и более одновременно открытым экземплярам приложения.  

### 3. _LocalStorage, SessionStorage_  
В рамках данного задания была изучена предложенная документация по LocalStorage и SessionStorage.  
Также, было выполнено задание: создать поле textarea, значение которого будет автоматически сохраняться при каждом его изменении. Когда пользователь закроет страницу и потом откроет её заново он должен увидеть последнее введённое значение. Исходный код выполненного задание размещен в ветке ToolsPWApplication данного репозитория.  
  
Ответы на вопроосы:  

_3.1 Каким типом хранилища является LocalStorage и SessionStorage?_  
Это тоже хранилище ключей/значений.  
  
_3.2 Какая последовательность работы с хранилищем?_  
Сперва необходимо с помощью метода setItem(key, value) назначить пару/ключ значение. Получить записанные данные по ключу можно с помощью метода getItem(key). Если нужно удалить данные с ключом key - используется метод removeItem(key). Для полной очистки хранилища существует метод clear().  

_3.3 Какой жизненный цикл хранилища?_  
Данные, которые записаны в sessionStorage, сохраняются после обновления страницы, а данные, записанные в localStorage - даже после перезапуска браузера и ОС.   

_3.4 Будет ли доступна информация из хранилища при закрытии веб-приложения? Если нет – какой тип хранилища надо использовать?_  
Да, но только данные, записанные в localStorage, поскольку они сохраняются даже после перезапуска браузера и даже ОС. Данные, записанные в sessionStorage, не сохранятся после закрытия приложения. Более того, хранилище sessionStorage даже для разных вкладок одного и того же приложения разное.  

_3.5 Будет ли доступно хранилище двум одновременно открытым экземплярам веб-приложения? Почему?_  
Хранилище localStorage привязано к источнику (домен/протокол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга. Поэтому, два одновременно открытых экземпляра приложения будут иметь доступ к хранилищу, ведь они будут на одних и тех же доменах/протоколах/портах. 

### 4. _Выводы:_  
В ходе данной лабораторной работы были получены базовые навыки работы с vue-cli и с его графической оболочкой vue UI. С помощью неё был создан каркас разрабатываемого приложения и добавлены такие компоненты, как awesome-vue и bootstrapvue.  
Затем, разработанные экраны приложения были сверстаны с использованием разметки BootstrapVue. Отличительная особенность Vue - реактивность. Она позволяет "на лету" отображать (функция render), удалять, изменять заранее описанные шаблоны (тег template). Таким образом, веб-странички, имеющие общий каркас и, возможно, даже одни и те же некоторые компоненты, могут быть созданы мгновенно из заранее созданных шаблонов. Кроме того, у шаблонов могут быть входные параметры, с помощью которых можно управлять контентом шаблона. Например, для двух одинаковых кнопок можно использовать один и тот же шаблон кнопки с параметром text, значение которого будет подставляться в кнопку.
